<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Object</title>
</head>
<body>
  <script>
    let o = new Object();
    
    o.foo = 42;
    
    console.log(o);
    // 객체 키 값 할당
    
    let undefinedObject = new Object(undefined);
    let nullObject = new Object(null);
    
    console.log(undefinedObject, nullObject);
    // undefined, null 객체 생성시 빈객체를 생성
    
    const target = { a: 1, b: 2 };
    const source = { b: 4, c: 5 };
    const newSource = { d: Symbol('임수현')};
    
    const returnedTarget = Object.assign(target, source);
    /* 
    target 객체에 source 객체를 붙여 넣는다.
    동일한 키값을 가진 경우는 덮어 쓴다.
    Object.assign()은 String 키와 Symbol 키 속성 모두 복사합니다
    */
    
    console.log(returnedTarget);
    console.log(target);
    
    Object.assign(returnedTarget, newSource);
    
    console.log(returnedTarget);
    console.log(typeof returnedTarget.d);
    
    // Object.assign()은 속성의 값을 복사하기 때문에, 깊은 복사를 수행하려면 다른 방법을 사용해야 합니다.
    /* 
    깊은 복사 vs. 얕은 복사:
    
    얕은 복사(Shallow Copy): 
    최상위 수준의 객체나 배열만 복사하고, 내부에 중첩된 객체나 배열은 원본과 참조를 공유합니다. 즉, 내부의 중첩된 객체를 수정하면 원본 객체도 영향을 받습니다.
    
    깊은 복사(Deep Copy): 
    객체나 배열의 모든 계층(중첩된 객체나 배열 포함)을 새롭게 복사하여 원본과 완전히 독립된 복사본을 만듭니다. 따라서 복사본을 수정해도 원본에 영향을 주지 않습니다. 
    */
    let obj1 = {a: 0, b: {c: 0}};
    let obj2 = Object.assign({}, obj1);
    
    obj1.a = 2;
    obj2.a = 4;
    obj2.b.c = 12;
    
    console.log(obj1);
    console.log(obj2);
    
    // 깊은 복사
    obj1 = {a:0, b: {c:0}};
    let obj3 = JSON.parse(JSON.stringify(obj1));
    obj1.a = 4;
    obj1.b.c = 4;
    console.log(obj3);
    
    // 객체 병합
    const o1 = { a: 1 };
    const o2 = { b: 2 };
    const o3 = { c: 3 };

    const obj = Object.assign(o1, o2, o3);
    console.log(obj);
  </script>
</body>
</html>